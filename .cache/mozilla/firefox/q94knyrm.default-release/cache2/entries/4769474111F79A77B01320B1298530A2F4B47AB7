// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license

(function($) {
    
    function maybeCall(thing, ctx) {
        return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
    };
    
    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = true;
        this.fixTitle();
    };
    
    Tipsy.prototype = {
        show: function() {
            var title = this.getTitle();
            if (title && this.enabled) {
                var $tip = this.tip();
                
                $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
                $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).prependTo(document.body);
                
                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });
                
                var actualWidth = $tip[0].offsetWidth,
                    actualHeight = $tip[0].offsetHeight,
                    gravity = maybeCall(this.options.gravity, this.$element[0]);
                
                var tp;
                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 's':
                        tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 'e':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
                        break;
                    case 'w':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
                        break;
                }
                
                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }
                
                $tip.css(tp).addClass('tipsy-' + gravity);
                $tip.find('.tipsy-arrow')[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
                if (this.options.className) {
                    $tip.addClass(maybeCall(this.options.className, this.$element[0]));
                }
                
                if (this.options.fade) {
                    $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'}).animate({opacity: this.options.opacity});
                } else {
                    $tip.css({visibility: 'visible', opacity: this.options.opacity});
                }
            }
        },
        
        hide: function() {
            if (this.options.fade) {
                this.tip().stop().fadeOut(function() { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },
        
        fixTitle: function() {
            var $e = this.$element;
            if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
                $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
            }
        },
        
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            this.fixTitle();
            var title, o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }
            title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },
        
        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"></div>').html('<div class="tipsy-arrow"></div><div class="tipsy-inner"></div>');
            }
            return this.$tip;
        },
        
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        
        enable: function() { this.enabled = true; },
        disable: function() { this.enabled = false; },
        toggleEnabled: function() { this.enabled = !this.enabled; }
    };
    
    $.fn.tipsy = function(options) {
        
        if (options === true) {
            return this.data('tipsy');
        } else if (typeof options == 'string') {
            var tipsy = this.data('tipsy');
            if (tipsy) tipsy[options]();
            return this;
        }
        
        options = $.extend({}, $.fn.tipsy.defaults, options);
        
        function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
                tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
                $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
        }
        
        function enter() {
            var tipsy = get(this);
            tipsy.hoverState = 'in';
            if (options.delayIn == 0) {
                tipsy.show();
            } else {
                tipsy.fixTitle();
                setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
        };
        
        function leave() {
            var tipsy = get(this);
            tipsy.hoverState = 'out';
            if (options.delayOut == 0) {
                tipsy.hide();
            } else {
                setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
        };
        
        if (!options.live) this.each(function() { get(this); });
        
        if (options.trigger != 'manual') {
            var binder   = options.live ? 'live' : 'bind',
                eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus',
                eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur';
            this[binder](eventIn, enter)[binder](eventOut, leave);
        }
        
        return this;
        
    };
    
    $.fn.tipsy.defaults = {
        className: null,
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: false,
        offset: 0,
        opacity: 0.8,
        title: 'title',
        trigger: 'hover'
    };
    
    // Overwrite this method to provide options on a per-element basis.
    // For example, you could store the gravity in a 'tipsy-gravity' attribute:
    // return $.extend({}, options, {gravity: $(ele).attr('tipsy-gravity') || 'n' });
    // (remember - do not modify 'options' in place!)
    $.fn.tipsy.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
    };
    
    $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };
    
    $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };
    
    /**
     * yields a closure of the supplied parameters, producing a function that takes
     * no arguments and is suitable for use as an autogravity function like so:
     *
     * @param margin (int) - distance from the viewable region edge that an
     *        element should be before setting its tooltip's gravity to be away
     *        from that edge.
     * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
     *        if there are no viewable region edges effecting the tooltip's
     *        gravity. It will try to vary from this minimally, for example,
     *        if 'sw' is preferred and an element is near the right viewable 
     *        region edge, but not the top edge, it will set the gravity for
     *        that element's tooltip to be 'se', preserving the southern
     *        component.
     */
     $.fn.tipsy.autoBounds = function(margin, prefer) {
		return function() {
			var dir = {ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false)},
			    boundTop = $(document).scrollTop() + margin,
			    boundLeft = $(document).scrollLeft() + margin,
			    $this = $(this);

			if ($this.offset().top < boundTop) dir.ns = 'n';
			if ($this.offset().left < boundLeft) dir.ew = 'w';
			if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
			if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

			return dir.ns + (dir.ew ? dir.ew : '');
		}
	};
    
})(jQuery);
        20200727193539>      $   maybeCall   Tipsy	   show	   hide   fixTitle   getTitle   tip   validate   enable   disable   toggleEnabled   prototype   fn   $.fn.tipsy   get   enter   tipsy   leave   options   className   delayIn   delayOut	   fade   fallback   gravity	   html	   live   offset   opacity   title   trigger      n   hover   defaults3   $.fn.tipsy.elementOptions   elementOptions#   $.fn.tipsy.autoNS   autoNS#   $.fn.tipsy.autoWE   autoWE+   $.fn.tipsy.autoBounds   margin   prefer   autoBounds   jQuery   binder   eventIn   eventOut   .this	   data   string   extend	   each   $.fn.tipsy/<   manual	   bind   mouseenter   focus   mouseleave	   blur    l$      l$  ¿         l$  // tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license

(function($) {
    
    function maybeCall(thing, ctx) {
        return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
    };
    
    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.enabled = true;
        this.fixTitle();
    };
    
    Tipsy.prototype = {
        show: function() {
            var title = this.getTitle();
            if (title && this.enabled) {
                var $tip = this.tip();
                
                $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
                $tip.remove().css({top: 0, left: 0, visibility: 'hidden', display: 'block'}).prependTo(document.body);
                
                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });
                
                var actualWidth = $tip[0].offsetWidth,
                    actualHeight = $tip[0].offsetHeight,
                    gravity = maybeCall(this.options.gravity, this.$element[0]);
                
                var tp;
                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 's':
                        tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2};
                        break;
                    case 'e':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset};
                        break;
                    case 'w':
                        tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset};
                        break;
                }
                
                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }
                
                $tip.css(tp).addClass('tipsy-' + gravity);
                $tip.find('.tipsy-arrow')[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
                if (this.options.className) {
                    $tip.addClass(maybeCall(this.options.className, this.$element[0]));
                }
                
                if (this.options.fade) {
                    $tip.stop().css({opacity: 0, display: 'block', visibility: 'visible'}).animate({opacity: this.options.opacity});
                } else {
                    $tip.css({visibility: 'visible', opacity: this.options.opacity});
                }
            }
        },
        
        hide: function() {
            if (this.options.fade) {
                this.tip().stop().fadeOut(function() { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },
        
        fixTitle: function() {
            var $e = this.$element;
            if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
                $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
            }
        },
        
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            this.fixTitle();
            var title, o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }
            title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },
        
        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"></div>').html('<div class="tipsy-arrow"></div><div class="tipsy-inner"></div>');
            }
            return this.$tip;
        },
        
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        
        enable: function() { this.enabled = true; },
        disable: function() { this.enabled = false; },
        toggleEnabled: function() { this.enabled = !this.enabled; }
    };
    
    $.fn.tipsy = function(options) {
        
        if (options === true) {
            return this.data('tipsy');
        } else if (typeof options == 'string') {
            var tipsy = this.data('tipsy');
            if (tipsy) tipsy[options]();
            return this;
        }
        
        options = $.extend({}, $.fn.tipsy.defaults, options);
        
        function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
                tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
                $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
        }
        
        function enter() {
            var tipsy = get(this);
            tipsy.hoverState = 'in';
            if (options.delayIn == 0) {
                tipsy.show();
            } else {
                tipsy.fixTitle();
                setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
        };
        
        function leave() {
            var tipsy = get(this);
            tipsy.hoverState = 'out';
            if (options.delayOut == 0) {
                tipsy.hide();
            } else {
                setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
        };
        
        if (!options.live) this.each(function() { get(this); });
        
        if (options.trigger != 'manual') {
            var binder   = options.live ? 'live' : 'bind',
                eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus',
                eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur';
            this[binder](eventIn, enter)[binder](eventOut, leave);
        }
        
        return this;
        
    };
    
    $.fn.tipsy.defaults = {
        className: null,
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: false,
        offset: 0,
        opacity: 0.8,
        title: 'title',
        trigger: 'hover'
    };
    
    // Overwrite this method to provide options on a per-element basis.
    // For example, you could store the gravity in a 'tipsy-gravity' attribute:
    // return $.extend({}, options, {gravity: $(ele).attr('tipsy-gravity') || 'n' });
    // (remember - do not modify 'options' in place!)
    $.fn.tipsy.elementOptions = function(ele, options) {
        return $.metadata ? $.extend({}, options, $(ele).metadata()) : options;
    };
    
    $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };
    
    $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };
    
    /**
     * yields a closure of the supplied parameters, producing a function that takes
     * no arguments and is suitable for use as an autogravity function like so:
     *
     * @param margin (int) - distance from the viewable region edge that an
     *        element should be before setting its tooltip's gravity to be away
     *        from that edge.
     * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
     *        if there are no viewable region edges effecting the tooltip's
     *        gravity. It will try to vary from this minimally, for example,
     *        if 'sw' is preferred and an element is near the right viewable 
     *        region edge, but not the top edge, it will set the gravity for
     *        that element's tooltip to be 'se', preserving the southern
     *        component.
     */
     $.fn.tipsy.autoBounds = function(margin, prefer) {
		return function() {
			var dir = {ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false)},
			    boundTop = $(document).scrollTop() + margin,
			    boundLeft = $(document).scrollLeft() + margin,
			    $this = $(this);

			if ($this.offset().top < boundTop) dir.ns = 'n';
			if ($this.offset().left < boundLeft) dir.ew = 'w';
			if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
			if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

			return dir.ns + (dir.ew ? dir.ew : '');
		}
	};
    
})(jQuery);
  ,   http://dotshare.it/public/js/jquery.tipsy.js   ≥!´!á!´!ˇˇˇˇ            å!´!ç!´!     † •   a$  ù   a$  Ñ@   	   3   ≥!´!å!´!ˇˇˇˇ                    å!´!ç!´!     †    ∆   #  ¥   #               5ûå!´!ç!´!     †    <  –  .  –              5ûå!´!é!´!    	   é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!	   ã!´!é!´!
   ã!´!é!´!   ã!´!    å!´!ç!´!      †
     ª  ˝  ª              5ûé!´!   å!´!ç!´!      †
   ‹  §  ‘  §  L         å!´!  †8  P  0  P  N   2         5û 5ûé!´!   å!´!ç!´!      †
   …  µ  ¡  µ  T            5ûé!´!   å!´!ç!´!      †
   ⁄  ¬  “  ¬  [            5ûé!´!   å!´!ç!´!      †
   ‚  Ω  ⁄  Ω  h            5ûé!´!   å!´!ç!´!      †
   ‚  ñ  ⁄  ñ  o            5ûé!´!   å!´!ç!´!      †
	   π  ‘  ±  ‘  w            5ûé!´!	   å!´!ç!´!      †

   Ô    Á    x            5ûé!´!
   å!´!ç!´!      †
   ,  P  $  P  y            5ûé!´!   é!´!   é!´!   å!´!ç!´!     †    v  h  n  h  B|         ≥!´!å!´!ˇˇˇˇ	                  /   0   1   2         å!´!ç!´!    	 †    ﬂ  ﬁ  ”  ﬁ  à             5ûå!´!ç!´!    	  †    ˛  H    H  ë      B   å!´!  †Î    „    ò   #          5ûä!´!ä!´!é!´!    5ûå!´!ç!´!    	  †    i  ï  [  ï  ú      B   å!´!  †6  i  .  i  ¢   #          5ûä!´!ä!´!é!´!    5ûé!´!3   é!´!   é!´!4   é!´!5   å!´!é!´!            é!´!   é!´!#   é!´!   é!´!6   å!´!ç!´!    	  †7   Õ  ﬁ  ≈  ﬁ  ¶   -         5ûé!´!   é!´!8   é!´!9   é!´!"   é!´!:   é!´!;   é!´!<   é!´!=   öò;¯   ü                            3    ! €«  ‹j   »   ‹j   «  ‹j   «  ‹º   ò#   ï   ª  ﬁG   ·   s †ó`   ï   º      òJ   ï   ª  ﬁG   ·   s «   ‹ª   ò   ï   ª   ﬁº   I·w  ‹ï   ª  †ï   º  ﬁG   ·5   º  F	   F   F
   º   s »   ‹º   F   ò   ï   ª  ﬁG   ·j   w ‹ï    º   F      ò’   ï$   º   F   ò   ï'      ó   ï'      ï'   «  ‹º   F      ò   ï+      ó   ï+      ï+   «  ‹º   F      ò   ï/      ó   ï/      ï/   «  ‹ª  ﬁª  I·ª  ª  s ﬁª  I·ª  ª  w ‹ï3   ª  †£•@~ `Pë0 `Pê PCÄ  ± KÄ  Ä `Pñ0 `Pê P8 `P.`P,P9 `PDÄ  ± FÄ  Ü `P™ PIÄ  ö@Ä  §00 `Pï `Pê P90 `Pö0 `P≤0 `P∏0 `P∏0 `Pì Pí P900 `P40 Q     5ûé!´!   å!´!é!´!       é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!é!´!   ã!´!    é!´!   é!´!   é!´!   é!´!   é!´!    é!´!   é!´!!   é!´!   é!´!   é!´!   é!´!   é!´!   é!´!   é!´!"   é!´!   é!´!#   å!´!ç!´!     †$   Í  P  ‚  P  ∆   (          5ûé!´!%   å!´!ç!´!      †&   w  Á  o  Á                5ûé!´!'   å!´!ç!´!      †(           Œ             5ûé!´!)   å!´!ç!´!     †*   "  Y$  ˚!  Y$  ·   %   @   å!´!  †'"  V$  "  V$  ‚            5ûé!´!+   é!´!,    5ûé!´!-   öò;¯x  ì                              2     j   »   ‹j   »   ‹º   5   j   9   j   9   j   9	   j
   9   j   9   j   9   j   9   j   9   j   9   K   ‹º   F   j   K   ‹º   F   F   5   9   9   9   9      9    !   9"   9#   9$   9%   
öôôôôôÈ?9&   '   9'   (   9)   K*   ‹º   F   F   j+   K,   ‹º   F   F   j-   K.   ‹º   F   F   j/   K0   ‹º   F   F   j1   K2   ‹£ñ@
@@ `P: JL JT J[ Jh Jo Jw : : ê@| `Pï@Ä  ≥ `Pî0 6 6 6 6 : : 6 6 6 > : ê@Ä  ∆ `Pö0000 `Pö0000 `Pö@Ä  · `Pö@Ä  ÒP     5ûé!´!.   öò;¯                                       j    π   w ‹£@ `PFÄ  Ò%P4P   )Ñ2@Ôt      _3à¬_3á"B Î7_<¶n   -    :http://dotshare.it/public/js/jquery.tipsy.js necko:classified 1 strongly-framed 1 request-method GET response-head HTTP/1.1 200 OK
Date: Wed, 12 Aug 2020 04:11:27 GMT
Server: Apache/2.4.10 (Unix) PHP/5.5.21 mod_wsgi/4.4.5 Python/2.7.9
Last-Modified: Fri, 30 Jan 2015 08:53:42 GMT
ETag: "246c-50ddabdd7622f"
Accept-Ranges: bytes
Content-Length: 9324
Content-Type: application/javascript
 original-response-headers Date: Wed, 12 Aug 2020 04:11:27 GMT
Server: Apache/2.4.10 (Unix) PHP/5.5.21 mod_wsgi/4.4.5 Python/2.7.9
Last-Modified: Fri, 30 Jan 2015 08:53:42 GMT
ETag: "246c-50ddabdd7622f"
Accept-Ranges: bytes
Content-Length: 9324
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: application/javascript
 ctid 2 uncompressed-len 0 net-response-time-onstart 1053 net-response-time-onstop 1057 alt-data 1;9324,javascript/moz-bytecode-20200727193539 alt-data-from-child 1   Z5